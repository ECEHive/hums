import {
	boolean,
	integer,
	pgEnum,
	pgTable,
	serial,
	text,
	time,
	timestamp,
	unique,
} from "drizzle-orm/pg-core";

/**
 * Users represent individuals who can log into the system.
 */
export const users = pgTable("users", {
	id: serial("id").primaryKey(),

	username: text("username").notNull().unique(),
	name: text("name").notNull(),
	email: text("email").notNull().unique(),

	isSystemUser: boolean("is_system_user").notNull().default(false),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

/**
 * Roles represent a collection of permissions that can be assigned to users.
 */
export const roles = pgTable("roles", {
	id: serial("id").primaryKey(),

	name: text("name").notNull().unique(),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

/**
 * Permissions represent specific actions that can be performed in the system.
 *
 * These should be generated by database migrations, and can not be edited.
 */
export const permissions = pgTable("permissions", {
	id: serial("id").primaryKey(),

	name: text("name").notNull().unique(),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

/**
 * Mapping table for many-to-many relationship between roles and permissions.
 *
 * A role can have multiple permissions, and a permission can be assigned to multiple roles.
 */
export const rolePermissions = pgTable(
	"role_permissions",
	{
		id: serial("id").primaryKey(),

		roleId: integer("role_id")
			.notNull()
			.references(() => roles.id, { onDelete: "cascade" }),
		permissionId: integer("permission_id")
			.notNull()
			.references(() => permissions.id, { onDelete: "cascade" }),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.roleId, t.permissionId)],
);

/**
 * Mapping table for many-to-many relationship between users and roles.
 *
 * A user can have multiple roles, and a role can be assigned to multiple users.
 */
export const userRoles = pgTable(
	"user_roles",
	{
		id: serial("id").primaryKey(),

		userId: integer("user_id")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),
		roleId: integer("role_id")
			.notNull()
			.references(() => roles.id, { onDelete: "cascade" }),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.userId, t.roleId)],
);

/**
 * Periods represent a large block of time during which shifts are scheduled.
 *
 * For example, a semester.
 */
export const periods = pgTable("periods", {
	id: serial("id").primaryKey(),

	name: text("name").notNull(),

	start: timestamp("start").notNull(),
	end: timestamp("end").notNull(),

	// Date range of when the period is visible to users
	visibleStart: timestamp("visible_start"),
	visibleEnd: timestamp("visible_end"),

	// Date range of when users can sign up for shifts
	scheduleSignupStart: timestamp("schedule_signup_start"),
	scheduleSignupEnd: timestamp("schedule_signup_end"),

	// Date range of when users can modify (drop/trade) assigned shifts
	scheduleModifyStart: timestamp("schedule_modify_start"),
	scheduleModifyEnd: timestamp("schedule_modify_end"),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

/**
 * Period Exceptions define time slots within a period where no shifts should occur.
 *
 * For example, holidays, or breaks.
 * Any shift occurrences that fall within these time ranges should not be generated.
 */
export const periodExceptions = pgTable("period_exceptions", {
	id: serial("id").primaryKey(),

	periodId: integer("period_id")
		.notNull()
		.references(() => periods.id, { onDelete: "cascade" }),

	name: text("name").notNull(),

	start: timestamp("start").notNull(),
	end: timestamp("end").notNull(),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const shiftTypeRoleRequirement = pgEnum("shift_type_role_requirement", [
	"disabled",
	"all",
	"any",
]);

/**
 * Shift Types define the types of shifts available in a period.
 *
 * For example, "3D Printing" or "Front Desk".
 */
export const shiftTypes = pgTable("shift_types", {
	id: serial("id").primaryKey(),

	periodId: integer("period_id")
		.notNull()
		.references(() => periods.id, { onDelete: "cascade" }),

	name: text("name").notNull(),
	location: text("location").notNull(),
	description: text("description"),
	color: text("color"),
	icon: text("icon"),

	isBalancedAcrossOverlap: boolean("is_balanced_across_overlap")
		.notNull()
		.default(false),
	isBalancedAcrossDay: boolean("is_balanced_across_day")
		.notNull()
		.default(false),
	isBalancedAcrossPeriod: boolean("is_balanced_across_period")
		.notNull()
		.default(false),
	canSelfAssign: boolean("allow_self_assign").notNull().default(true),

	doRequireRoles: shiftTypeRoleRequirement("do_require_roles")
		.notNull()
		.default("disabled"),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

/**
 * Mapping table for many-to-many relationship between shift types and roles.
 *
 * A shift type can require multiple roles, and a role can be required by multiple shift types.
 * This is used to restrict which users can sign up for certain shift types based on their roles.
 * It is only used if the shift type's `doRequireRoles` field is true.
 */
export const shiftTypeRoles = pgTable(
	"shift_type_roles",
	{
		id: serial("id").primaryKey(),

		shiftTypeId: integer("shift_type_id")
			.notNull()
			.references(() => shiftTypes.id, { onDelete: "cascade" }),
		roleId: integer("role_id")
			.notNull()
			.references(() => roles.id, { onDelete: "cascade" }),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.shiftTypeId, t.roleId)],
);

/**
 * Shift Schedules define the recurring shift schedule for a shift type.
 *
 * For example, "Every Monday from 9am to 12pm, slot 0".
 */
export const shiftSchedules = pgTable(
	"shift_schedules",
	{
		id: serial("id").primaryKey(),

		shiftTypeId: integer("shift_type_id")
			.notNull()
			.references(() => shiftTypes.id, { onDelete: "cascade" }),

		slot: integer("slot").notNull().default(0),
		dayOfWeek: integer("day_of_week").notNull(),
		startTime: time("start_time").notNull(),
		endTime: time("end_time").notNull(),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.shiftTypeId, t.dayOfWeek, t.startTime)],
);

/**
 * Shift Occurrences are individual instances of a shift schedule.
 *
 * These are generated from the shift schedules for a given period.
 * For example, "3D printing on Monday, January 1st, 2025 from 10:00am to 10:30am, slot 0".
 *
 * If a shift schedule has multiple slots (e.g., slot=3), then multiple occurrences
 * will be created for each timestamp, one for each slot (slot 0, 1, 2).
 */
export const shiftOccurrences = pgTable(
	"shift_occurrences",
	{
		id: serial("id").primaryKey(),

		shiftScheduleId: integer("shift_schedule_id")
			.notNull()
			.references(() => shiftSchedules.id, { onDelete: "cascade" }),
		timestamp: timestamp("timestamp").notNull(),
		slot: integer("slot").notNull().default(0),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.shiftScheduleId, t.timestamp, t.slot)],
);

/**
 * Assignments link users to shift schedules.
 *
 * These are used to assign users to recurring shifts.
 * For example, "User A is assigned to a 3D printing shift every Monday 9am-12pm, slot 0".
 */
export const shiftScheduleAssignments = pgTable(
	"shift_schedule_assignments",
	{
		id: serial("id").primaryKey(),

		shiftScheduleId: integer("shift_schedule_id")
			.notNull()
			.references(() => shiftSchedules.id, { onDelete: "cascade" }),
		userId: integer("user_id")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.shiftScheduleId, t.userId)],
);

export const shiftOccurrenceAssignmentsStatus = pgEnum(
	"shift_occurrence_assignment_status",
	["assigned", "dropped", "picked_up"],
);

/**
 * Shift Occurrence Assignments link users to specific shift occurrences.
 *
 * These are generated when a user assigns themselves to a specific shift occurrence,
 * or when the user picks up a dropped shift occurrence.
 * These are used to track which users are assigned to which specific shifts.
 * These are also used to track dropped and picked up shifts.
 * A new assignment should be created when a user picks up a currently dropped shift occurrence.
 * For example, "User A is assigned to the 3D printing shift on Monday, January 1st, 2025 from 10:00am to 10:30am".
 */
export const shiftOccurrenceAssignments = pgTable(
	"shift_occurrence_assignments",
	{
		id: serial("id").primaryKey(),

		shiftOccurrenceId: integer("shift_occurrence_id")
			.notNull()
			.references(() => shiftOccurrences.id, { onDelete: "cascade" }),
		userId: integer("user_id")
			.notNull()
			.references(() => users.id, { onDelete: "cascade" }),

		// Assignment lifecycle:
		// - assigned: user is currently assigned
		// - dropped: originally assigned but dropped by the user
		// New assignment created when another user picks up a `dropped` assignment:
		// - picked_up: another user picked up a dropped assignment
		status: shiftOccurrenceAssignmentsStatus("status")
			.notNull()
			.default("assigned"),

		createdAt: timestamp("created_at").notNull().defaultNow(),
		updatedAt: timestamp("updated_at").notNull().defaultNow(),
	},
	(t) => [unique().on(t.shiftOccurrenceId, t.userId)],
);

export const shiftAttendanceStatus = pgEnum("shift_attendance_status", [
	"present",
	"absent",
	"arrived_late",
	"left_early",
]);

/**
 * Shift Attendances track the attendance of users for specific shift occurrences.
 *
 * These are generated once the shift occurrence has actually started.
 * For example, "User A attended the 3D printing shift on Monday, January 1st, 2025 from 10:00am to 10:30am".
 */
export const shiftAttendances = pgTable("shift_attendances", {
	id: serial("id").primaryKey(),

	occurrenceAssignmentId: integer("occurrence_assignment_id")
		.notNull()
		.references(() => shiftOccurrenceAssignments.id, { onDelete: "cascade" }),

	status: shiftAttendanceStatus("status").notNull().default("absent"),

	timeIn: timestamp("time_in"),
	timeOut: timestamp("time_out"),

	createdAt: timestamp("created_at").notNull().defaultNow(),
	updatedAt: timestamp("updated_at").notNull().defaultNow(),
});
