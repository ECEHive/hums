generator client {
  provider   = "prisma-client"
  output     = "./generated"
  runtime    = "bun"
}

datasource db {
  provider = "postgresql"
}

//
// Enums
//

enum ShiftTypeRoleRequirement {
  disabled
  all
  any
}

enum ShiftAttendanceStatus {
  upcoming
  present
  absent
  dropped
  dropped_makeup
  excused // Full credit granted due to approved excuse
}

enum SessionType {
  regular
  staffing
}

enum MinMaxUnit {
  count
  minutes
  hours
}

enum AuditLogSource {
  trpc
  rest
  slack
}

enum InventoryAction {
  CHECK_IN
  CHECK_OUT
}

//
// Models
//

model User {
  id Int @id @default(autoincrement())

  // fields
  username     String   @unique
  name         String
  email        String   @unique
  cardNumber   String?  @unique
  slackUsername String? @unique
  isSystemUser Boolean  @default(false)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  roles            Role[]
  shiftSchedules   ShiftSchedule[]
  shiftOccurrences     ShiftOccurrence[]
  auditLogs            AuditLog[]
  impersonatedAuditLogs AuditLog[] @relation("AuditLogImpersonators")

  // One-to-many
  sessions    Session[]
  attendances ShiftAttendance[]
  reviewedAttendances ShiftAttendance[] @relation("ShiftAttendanceReviewedBy")
  suspensions Suspension[]
  createdSuspensions Suspension[] @relation("SuspensionCreatedBy")
  
  // Many-to-many (explicit)
  userAgreements UserAgreement[]
  apiTokens     ApiToken[]

  // Inventory
  inventoryTransactions InventoryTransaction[]

  // Tickets
  submittedTickets Ticket[] @relation("TicketSubmitter")
  handledTickets   Ticket[] @relation("TicketHandler")
  ticketStatusChanges TicketStatusHistory[] @relation("TicketStatusChangedBy")
}

model Role {
  id Int @id @default(autoincrement())

  // fields
  name String @unique

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  permissions Permission[]
  users       User[]
  shiftTypes ShiftType[]
  periods    Period[]   @relation("PeriodRoles")
  
  // Inventory approval roles (items that require this role to approve checkout/checkin)
  approvalItems Item[] @relation("ItemApprovalRoles")
}

model Permission {
  id Int @id @default(autoincrement())

  // fields
  name String @unique

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  roles Role[]
}

// RolePermission and UserRole converted to implicit many-to-many relations.

model Period {
  id Int @id @default(autoincrement())

  // fields
  name  String
  start DateTime
  end   DateTime

  min       Int?
  max       Int?
  minMaxUnit MinMaxUnit?

  visibleStart DateTime
  visibleEnd   DateTime

  scheduleSignupStart DateTime
  scheduleSignupEnd   DateTime

  scheduleModifyStart DateTime
  scheduleModifyEnd   DateTime

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  periodExceptions PeriodException[]
  shiftTypes ShiftType[]
  roles      Role[]     @relation("PeriodRoles")
}

model PeriodException {
  id Int @id @default(autoincrement())

  // fields
  periodId Int
  name     String
  start    DateTime
  end      DateTime

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  period Period @relation(fields: [periodId], references: [id], onDelete: Cascade)
}

model ShiftType {
  id Int @id @default(autoincrement())

  // fields
  periodId    Int
  name        String
  location    String
  description String?
  color       String?
  icon        String?

  isBalancedAcrossOverlap Boolean @default(false)
  isBalancedAcrossDay     Boolean @default(false)
  isBalancedAcrossPeriod  Boolean @default(false)
  canSelfAssign           Boolean @default(true)

  doRequireRoles ShiftTypeRoleRequirement @default(disabled)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  period         Period          @relation(fields: [periodId], references: [id], onDelete: Cascade)
  roles          Role[]
  shiftSchedules ShiftSchedule[]
}

model ShiftSchedule {
  id Int @id @default(autoincrement())

  // fields
  shiftTypeId Int
  slots       Int    @default(1)
  dayOfWeek   Int
  startTime   String
  endTime     String

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  shiftType        ShiftType         @relation(fields: [shiftTypeId], references: [id], onDelete: Cascade)
  shiftOccurrences ShiftOccurrence[]
  users            User[]

  // constraints
  @@unique([shiftTypeId, dayOfWeek, startTime])
}

model ShiftOccurrence {
  id Int @id @default(autoincrement())

  // fields
  shiftScheduleId Int
  timestamp       DateTime
  slot            Int      @default(0)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  shiftSchedule ShiftSchedule     @relation(fields: [shiftScheduleId], references: [id], onDelete: Cascade)
  users         User[]
  attendances   ShiftAttendance[]

  // constraints
  @@unique([shiftScheduleId, timestamp, slot])
}

model ShiftAttendance {
  id Int @id @default(autoincrement())

  // fields
  shiftOccurrenceId Int
  userId            Int
  status            ShiftAttendanceStatus @default(absent)
  isMakeup          Boolean             @default(false)
  didArriveLate     Boolean             @default(false)
  didLeaveEarly     Boolean             @default(false)
  isExcused         Boolean             @default(false)
  droppedNotes      String?
  excuseNotes       String?             // Notes provided when excusing (only relevant when isExcused=true)
  timeIn            DateTime?
  timeOut           DateTime?
  // Review tracking:
  // - When null: issue is "pending review" (not yet reviewed by staff)
  // - When set with isExcused=true: issue was reviewed and excused
  // - When set with isExcused=false: issue was reviewed and marked as unexcused
  reviewedAt        DateTime?
  reviewedById      Int?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  shiftOccurrence ShiftOccurrence @relation(fields: [shiftOccurrenceId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  reviewedBy      User?           @relation("ShiftAttendanceReviewedBy", fields: [reviewedById], references: [id], onDelete: SetNull)

  // constraints
  @@unique([shiftOccurrenceId, userId])
}

model Session {
  id Int @id @default(autoincrement())

  // fields
  userId      Int
  sessionType SessionType @default(regular)
  startedAt   DateTime    @default(now())
  endedAt     DateTime?

  // relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([userId, endedAt])
}

model Device {
  id Int @id @default(autoincrement())

  // fields
  name      String
  ipAddress String  @unique
  isActive  Boolean @default(true)

  // Device access permissions
  hasKioskAccess      Boolean @default(true)
  hasDashboardAccess  Boolean @default(false)
  hasInventoryAccess  Boolean @default(false)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Agreement {
  id Int @id @default(autoincrement())

  // fields
  title            String
  content          String  @db.Text
  confirmationText String
  isEnabled        Boolean @default(true)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  userAgreements UserAgreement[]
}

model UserAgreement {
  id Int @id @default(autoincrement())

  // fields
  userId      Int
  agreementId Int

  // timestamps
  agreedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  agreement Agreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([userId, agreementId])
}

model ApiToken {
  id Int @id @default(autoincrement())

  // fields
  name        String
  description String?
  prefix      String @unique
  hashedKey   String @unique
  createdById Int?
  expiresAt   DateTime?
  lastUsedAt  DateTime?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  createdBy User? @relation(fields: [createdById], references: [id], onDelete: SetNull)
  auditLogs AuditLog[]
}

model AuditLog {
  id Int @id @default(autoincrement())

  // fields
  userId           Int
  impersonatedById Int?
  apiTokenId       Int?
  action           String
  metadata         Json    @default("{}")
  source           AuditLogSource
  createdAt        DateTime @default(now())

  // relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Restrict)
  impersonatedBy User?     @relation("AuditLogImpersonators", fields: [impersonatedById], references: [id], onDelete: SetNull)
  apiToken       ApiToken? @relation(fields: [apiTokenId], references: [id], onDelete: SetNull)

  // indexes
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([apiTokenId, createdAt])
  @@index([action, createdAt])
}

model OneTimeAccessCode {
  id Int @id @default(autoincrement())

  // fields
  code      String   @unique
  usedAt    DateTime?
  expiresAt DateTime

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // indexes
  @@index([code, expiresAt])
}

model ConfigValue {
  id Int @id @default(autoincrement())

  // fields
  key   String @unique
  value Json

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // indexes
  @@index([key])
}

model Suspension {
  id Int @id @default(autoincrement())

  // fields
  userId        Int
  startDate     DateTime
  endDate       DateTime
  internalNotes String?  @db.Text  // Not shared with user
  externalNotes String?  @db.Text  // Shared with user
  createdById   Int?
  emailSentAt   DateTime?          // Track when suspension notice was sent

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdBy User? @relation("SuspensionCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  // indexes
  @@index([userId])
  @@index([startDate, endDate])
  @@index([emailSentAt, startDate])
}

model Item {
  id String @id @default(uuid())

  // fields
  name        String
  description String?
  sku         String?  @unique
  location    String?
  minQuantity Int?     // minimum quantity threshold for alerts
  link        String?  // ordering/product link
  isActive    Boolean  @default(true)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  transactions InventoryTransaction[]
  snapshot     InventorySnapshot?
  
  // Roles required to approve checkout/checkin for this item (any role in the list can approve)
  approvalRoles Role[] @relation("ItemApprovalRoles")
}

model InventoryTransaction {
  id String @id @default(uuid())

  // fields
  itemId   String
  userId   Int
  action   InventoryAction
  quantity Int             // positive or negative depending on action
  notes    String?

  // timestamps
  createdAt DateTime @default(now())

  // relations
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  // indexes
  @@index([itemId, createdAt])
}

model InventorySnapshot {
  // fields
  itemId   String   @id
  quantity Int      // authoritative quantity at snapshot time
  takenAt  DateTime @default(now())

  // relations
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

//
// Ticket System
//

enum TicketStatus {
  pending
  in_progress
  resolved
  closed
  cancelled
}

model TicketType {
  id Int @id @default(autoincrement())

  // fields
  name        String  @unique
  description String?
  icon        String? // Icon identifier for UI display
  color       String? // Color for UI display
  
  // Configuration
  requiresAuth Boolean @default(false) // Whether submission requires authentication
  isActive     Boolean @default(true)  // Whether this ticket type is available for submission
  sortOrder    Int     @default(0)     // Display order in ticket type list
  
  // Field schema (JSON Schema-like structure defining expected fields)
  fieldSchema Json

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  tickets Ticket[]
}

model Ticket {
  id String @id @default(uuid())

  // fields
  ticketTypeId Int
  status       TicketStatus @default(pending)
  
  // Dynamic data stored as JSON (validated against TicketType.fieldSchema)
  data Json
  
  // Optional submitter info (null if anonymous submission)
  submitterId Int?
  submitterEmail String? // For anonymous submissions or as backup contact
  submitterName  String? // For anonymous submissions
  
  // Handler/assignee for the ticket
  handlerId Int?
  
  // Notes for internal use
  internalNotes String? @db.Text
  
  // Resolution notes (visible to submitter)
  resolutionNotes String? @db.Text

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  resolvedAt DateTime?

  // relations
  ticketType TicketType @relation(fields: [ticketTypeId], references: [id], onDelete: Restrict)
  submitter  User?      @relation("TicketSubmitter", fields: [submitterId], references: [id], onDelete: SetNull)
  handler    User?      @relation("TicketHandler", fields: [handlerId], references: [id], onDelete: SetNull)
  
  statusHistory TicketStatusHistory[]

  // indexes
  @@index([ticketTypeId])
  @@index([submitterId])
  @@index([handlerId])
  @@index([status])
  @@index([createdAt])
}

model TicketStatusHistory {
  id Int @id @default(autoincrement())

  // fields
  ticketId     String
  previousStatus TicketStatus?
  newStatus      TicketStatus
  notes          String? @db.Text
  changedById    Int?

  // timestamps
  createdAt DateTime @default(now())

  // relations
  ticket    Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  changedBy User?  @relation("TicketStatusChangedBy", fields: [changedById], references: [id], onDelete: SetNull)

  // indexes
  @@index([ticketId])
  @@index([createdAt])
}
