generator client {
  provider   = "prisma-client"
  output     = "./generated"
  engineType = "client"
  runtime    = "bun"
}

datasource db {
  provider = "postgresql"
}

//
// Enums
//

enum ShiftTypeRoleRequirement {
  disabled
  all
  any
}

enum ShiftAttendanceStatus {
  upcoming
  present
  absent
  dropped
  dropped_makeup
}

enum SessionType {
  regular
  staffing
}

enum MinMaxUnit {
  count
  minutes
  hours
}

enum AuditLogSource {
  trpc
  rest
  slack
}

enum InventoryAction {
  CHECK_IN
  CHECK_OUT
}

enum ItemRequestStatus {
  PENDING
  APPROVED
  REJECTED
  FULFILLED
  CANCELLED
}

//
// Models
//

model User {
  id Int @id @default(autoincrement())

  // fields
  username     String   @unique
  name         String
  email        String   @unique
  cardNumber   String?  @unique
  slackUsername String? @unique
  isSystemUser Boolean  @default(false)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  roles            Role[]
  shiftSchedules   ShiftSchedule[]
  shiftOccurrences     ShiftOccurrence[]
  auditLogs            AuditLog[]
  impersonatedAuditLogs AuditLog[] @relation("AuditLogImpersonators")

  // One-to-many
  sessions    Session[]
  attendances ShiftAttendance[]
  suspensions Suspension[]
  createdSuspensions Suspension[] @relation("SuspensionCreatedBy")
  
  // Many-to-many (explicit)
  userAgreements UserAgreement[]
  apiTokens     ApiToken[]

  // Inventory
  inventoryTransactions InventoryTransaction[]
  itemRequests          ItemRequest[]         @relation("ItemRequestUser")
  reviewedItemRequests  ItemRequest[]         @relation("ItemRequestReviewer")
}

model Role {
  id Int @id @default(autoincrement())

  // fields
  name String @unique

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  permissions Permission[]
  users       User[]
  shiftTypes ShiftType[]
  periods    Period[]   @relation("PeriodRoles")
}

model Permission {
  id Int @id @default(autoincrement())

  // fields
  name String @unique

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  roles Role[]
}

// RolePermission and UserRole converted to implicit many-to-many relations.

model Period {
  id Int @id @default(autoincrement())

  // fields
  name  String
  start DateTime
  end   DateTime

  min       Int?
  max       Int?
  minMaxUnit MinMaxUnit?

  visibleStart DateTime
  visibleEnd   DateTime

  scheduleSignupStart DateTime
  scheduleSignupEnd   DateTime

  scheduleModifyStart DateTime
  scheduleModifyEnd   DateTime

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  periodExceptions PeriodException[]
  shiftTypes ShiftType[]
  roles      Role[]     @relation("PeriodRoles")
}

model PeriodException {
  id Int @id @default(autoincrement())

  // fields
  periodId Int
  name     String
  start    DateTime
  end      DateTime

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  period Period @relation(fields: [periodId], references: [id], onDelete: Cascade)
}

model ShiftType {
  id Int @id @default(autoincrement())

  // fields
  periodId    Int
  name        String
  location    String
  description String?
  color       String?
  icon        String?

  isBalancedAcrossOverlap Boolean @default(false)
  isBalancedAcrossDay     Boolean @default(false)
  isBalancedAcrossPeriod  Boolean @default(false)
  canSelfAssign           Boolean @default(true)

  doRequireRoles ShiftTypeRoleRequirement @default(disabled)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  period         Period          @relation(fields: [periodId], references: [id], onDelete: Cascade)
  roles          Role[]
  shiftSchedules ShiftSchedule[]
}

model ShiftSchedule {
  id Int @id @default(autoincrement())

  // fields
  shiftTypeId Int
  slots       Int    @default(1)
  dayOfWeek   Int
  startTime   String
  endTime     String

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  shiftType        ShiftType         @relation(fields: [shiftTypeId], references: [id], onDelete: Cascade)
  shiftOccurrences ShiftOccurrence[]
  users            User[]

  // constraints
  @@unique([shiftTypeId, dayOfWeek, startTime])
}

model ShiftOccurrence {
  id Int @id @default(autoincrement())

  // fields
  shiftScheduleId Int
  timestamp       DateTime
  slot            Int      @default(0)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  shiftSchedule ShiftSchedule     @relation(fields: [shiftScheduleId], references: [id], onDelete: Cascade)
  users         User[]
  attendances   ShiftAttendance[]

  // constraints
  @@unique([shiftScheduleId, timestamp, slot])
}

model ShiftAttendance {
  id Int @id @default(autoincrement())

  // fields
  shiftOccurrenceId Int
  userId            Int
  status            ShiftAttendanceStatus @default(absent)
  isMakeup          Boolean             @default(false)
  didArriveLate     Boolean             @default(false)
  didLeaveEarly     Boolean             @default(false)
  droppedNotes      String?
  timeIn            DateTime?
  timeOut           DateTime?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  shiftOccurrence ShiftOccurrence @relation(fields: [shiftOccurrenceId], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([shiftOccurrenceId, userId])
}

model Session {
  id Int @id @default(autoincrement())

  // fields
  userId      Int
  sessionType SessionType @default(regular)
  startedAt   DateTime    @default(now())
  endedAt     DateTime?

  // relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([userId, endedAt])
}

model Device {
  id Int @id @default(autoincrement())

  // fields
  name      String
  ipAddress String  @unique
  isActive  Boolean @default(true)

  // Device access permissions
  hasKioskAccess      Boolean @default(true)
  hasDashboardAccess  Boolean @default(false)
  hasInventoryAccess  Boolean @default(false)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
}

model Agreement {
  id Int @id @default(autoincrement())

  // fields
  title            String
  content          String  @db.Text
  confirmationText String
  isEnabled        Boolean @default(true)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  userAgreements UserAgreement[]
}

model UserAgreement {
  id Int @id @default(autoincrement())

  // fields
  userId      Int
  agreementId Int

  // timestamps
  agreedAt  DateTime @default(now())
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  agreement Agreement @relation(fields: [agreementId], references: [id], onDelete: Cascade)

  // constraints
  @@unique([userId, agreementId])
}

model ApiToken {
  id Int @id @default(autoincrement())

  // fields
  name        String
  description String?
  prefix      String @unique
  hashedKey   String @unique
  createdById Int?
  expiresAt   DateTime?
  lastUsedAt  DateTime?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  createdBy User? @relation(fields: [createdById], references: [id], onDelete: SetNull)
  auditLogs AuditLog[]
}

model AuditLog {
  id Int @id @default(autoincrement())

  // fields
  userId           Int
  impersonatedById Int?
  apiTokenId       Int?
  action           String
  metadata         Json    @default("{}")
  source           AuditLogSource
  createdAt        DateTime @default(now())

  // relations
  user           User      @relation(fields: [userId], references: [id], onDelete: Restrict)
  impersonatedBy User?     @relation("AuditLogImpersonators", fields: [impersonatedById], references: [id], onDelete: SetNull)
  apiToken       ApiToken? @relation(fields: [apiTokenId], references: [id], onDelete: SetNull)

  // indexes
  @@index([createdAt])
  @@index([userId, createdAt])
  @@index([apiTokenId, createdAt])
  @@index([action, createdAt])
}

model OneTimeAccessCode {
  id Int @id @default(autoincrement())

  // fields
  code      String   @unique
  usedAt    DateTime?
  expiresAt DateTime

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // indexes
  @@index([code, expiresAt])
}

model ConfigValue {
  id Int @id @default(autoincrement())

  // fields
  key   String @unique
  value Json

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // indexes
  @@index([key])
}

model Suspension {
  id Int @id @default(autoincrement())

  // fields
  userId        Int
  startDate     DateTime
  endDate       DateTime
  internalNotes String?  @db.Text  // Not shared with user
  externalNotes String?  @db.Text  // Shared with user
  createdById   Int?
  emailSentAt   DateTime?          // Track when suspension notice was sent

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  user      User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdBy User? @relation("SuspensionCreatedBy", fields: [createdById], references: [id], onDelete: SetNull)

  // indexes
  @@index([userId])
  @@index([startDate, endDate])
  @@index([emailSentAt, startDate])
}

model Item {
  id String @id @default(uuid())

  // fields
  name        String
  description String?
  sku         String?  @unique
  location    String?
  minQuantity Int?     // minimum quantity threshold for alerts
  isActive    Boolean  @default(true)

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  // relations
  transactions InventoryTransaction[]
  snapshot     InventorySnapshot?
  requests     ItemRequest[]
}

model InventoryTransaction {
  id String @id @default(uuid())

  // fields
  itemId   String
  userId   Int
  action   InventoryAction
  quantity Int             // positive or negative depending on action
  notes    String?

  // timestamps
  createdAt DateTime @default(now())

  // relations
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Restrict)

  // indexes
  @@index([itemId, createdAt])
}

model InventorySnapshot {
  // fields
  itemId   String   @id
  quantity Int      // authoritative quantity at snapshot time
  takenAt  DateTime @default(now())

  // relations
  item Item @relation(fields: [itemId], references: [id], onDelete: Cascade)
}

model ItemRequest {
  id String @id @default(uuid())

  // fields
  itemId          String?
  requestedItemName String?           // For items that don't exist yet
  quantity        Int
  reason          String?
  status          ItemRequestStatus @default(PENDING)
  reviewNotes     String?
  requestedById   Int
  reviewedById    Int?

  // timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  reviewedAt DateTime?

  // relations
  item       Item? @relation(fields: [itemId], references: [id], onDelete: SetNull)
  requestedBy User @relation("ItemRequestUser", fields: [requestedById], references: [id], onDelete: Cascade)
  reviewedBy  User? @relation("ItemRequestReviewer", fields: [reviewedById], references: [id], onDelete: SetNull)

  // indexes
  @@index([requestedById])
  @@index([status, createdAt])
}
